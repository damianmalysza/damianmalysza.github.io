---
layout: post
title:      "Lessons Learned From My First CLI Project"
date:       2020-11-30 20:40:04 -0500
permalink:  lessons_learned_from_my_first_cli_project
---


Going through and creating my first solo CLI project was a learning experience (to say the least), but in a surprising way. I expected for this project to test my technical Ruby knowledge that I learned over the course of the preceding lessons. However, I didn't expect to be tested in *project-management* type skills. In fact, I spent more time planning and structuring the project than *writing* actual code - which boggled my mind the most. It's made me truly grow an appreciation for the *measure twice, cut once* type of approach and how it can help out with software projects, even small ones like this.


So what exactly do I mean by *project managment* skills? I could be using the wrong terminology here, but what I mean is all the *stuff* you do besides actual coding. At high level, these are the types of activities I tried to do before even typing a line of code:
* Look through various websites and public API's to see what type of data source I could use for my project
* Analyze the source and come up functionality that would useful for a user based off of that data source. This involved looking at JSON that API's return and inspecting HTML elements of websites to see what is "scrapeable"
* Write out the specific functions and interaction that the user would have with the application based off those functions (i.e. the "main menu")
* Sketch out the classes that would need to be made and how they would collaborate with each other (diagraming where possible) 
* Sketch out methods that would be defined in each class and pseudocode out the logic of each method


Doing all the above took the majority of total time spent on this project, but I felt it was necessary to get me in a good spot to make the actual coding as easy as possibly. Now with all this, you would think that the project would be a breeze and I would have zero hiccups ... **WRONG**. Let's walk through what went wrong for me and, with that, also explain what my application does (because I just realized I never even talked about). 

My idea was to create a "Cocktail List of Info" application, or 'CLI' for short (haha). The main function of the application would be to allow the user to search for a cocktail and get information for how to create it. The application was going to utilize the same structure that was taught in some of the Object Oriented labs, i.e. Scraper class to scrape information from a web source, Drink class to create drink objects based on the information scraped, and a CLI Controller class that would be responsible for user interaction. I initially came upon this idea by looking through this [list](https://github.com/public-apis/public-apis) of public API's (shout-outs to this awesome list), and coming upon the [CocktailDB API](https://www.thecocktaildb.com/api.php). I saw that the API had functions like searching by cocktail by name, filtering by ingredient, and looking up a random cocktail. My initial thinking was that I could model my application after these specific API calls (i.e. match the function to the API call) and half of my project would essentially be done. This was a mistake, but also an important project management lesson learned - I don't know what the formal or buzzwordy term for this is, but *stick to the requirements of the project*. 

So ... what was the mistake and how exactly did I deviate from requirements? When I decided to model my project based on those API calls I mentioned earlier, I was unknowlingly tailoring the application around what information the API can offer me, rather than tailoring the application  towards the requirements of what the project needs to accomplish. To put in more lamen terms, I saw these three functions that the API can offer without any additional work from me and hopped on them like a discounted 65" TV at Walmart on Black Friday (before COVID times). From there, I just leaned in more and more into using those API calls. I made a couple of diagrams of how they would work, but they were extremely high-level and didn't go into detail of how exactly objects would collaborate. I felt good about making diagrams and called it an end to planning and went into coding. 

When I got into the actual development phase of the project, I started thinking more specifically about the classes I needed to make and what they would do (which I should've done in planning). As I mentioned before, I knew that I needed a Scraper, Drink, and CLI Controller class. I created the Scraper methods that would get information from each API call (using HTTParty), and was thinking about how and when instances of my Drink classes should be instantiated. I ran into a few problems here. Firstly, given that the logic for processing the user's input (e.g., a drink search) resided with the API rather than anything I coded in, I had to wait on user input to actually tell the Scraper class to call the "search drink" API, which would then create Drink objects based on that search. This wasn't good for speediness of the application, but then I also ran into the issue of accounting for which drink objects were already created in the case that the user's input queried a drink that already had an instance made. After thinking for way longer than I should've on the best way to handle this, I came to realization that making the drink objects was in itself an unnecessary step, because the information that the API gives back already contains everything that the Drink object would store. In actuality, all I needed to do was just format the JSON output given back from the API correctly, and that would deliver the same function (at least to the user's perspective); however, that misses the point of this project - using Objects to store information and then allows users to interact with those objects. I was now doing a pure web scraping project instead of meeting the requirements of the project and showing off all cool Object Oriented Programming tricks I picked up through all the Flat Iron lessons and labs.

Upon that realization, I scrapped using the CocktailDB API but wanted to maintain the same or similar functionality. I found a good old [cocktail website](https://uk.thebar.com/cocktail-recipes?seeAll=true) (no API wizardry) that looked "scrapeable enough". The website is simple where it has one page of all the cocktails it has information on, and then allows you to click on the cocktail to get more information like ingredients and instructions. This kind of model and web source allowed me to fit more into the three-class paradigm I mentioned before (Scraper, Drink, CLI Controller) by allowing me scrape and instantiate Drink objects using logic that I code rather than relying on the logic of the API. This also allowed me to highlight all the techniques learned throughout the Ruby section, and specifically, techniques related to Object Oriented programming. 

All in all, this project was a great and fulfilling experience. It was great to create something from nothing and take the training wheels off a bit. I learned that it's *crucial* to understand the requirements of a project and ensure that your planning is always taking into account those requirements. I also learned that it's important to be as specific as possible during planning, at least when planning at the level of archtecting your Objects and how they will collaborate.

In the end, I was able to create a product that I'm pretty proud of - check it out [here](https://github.com/damianmalysza/cocktail_cli). 


